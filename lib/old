#include "Chunker.hpp"
#include <string>
#include <iostream>
#include <fstream>
#include <filesystem>
#include <sstream>
#include <cstring>
#include <leveldb/db.h>

std::string Chunker::simpleRead() {

	return "";
}

// The header is "SHADOW"
//
// The Table of Contents Section (a.k.a the TOC Section) is stored
// right after the header and contains the offsets and file sizes of
// every file.
//
// The Data Section is stored right after the TOC Section and contains
// nothing but a blob of all the file data.
// The write cursor/offset is equal to 0 where the data section starts

// Chunker File Format:
// <HEADER>
// <Array>
// 	[File Name]
// 	[Pointer to location in file]
// 	[Size of file]
// </Array>
// <Array>
//	[File data]
// </Array>

int Chunker::chunkFolder(std::string folderpath, Chunker::CompressionType compression) {
	std::ifstream folderToChunk(folderpath);
	if (!folderToChunk) {
		std::cerr << "Unable to open given folder" << std::endl;
		return 1;
	}

	bool dirstatus = std::filesystem::create_directory("./ChunkerData");
	if (!dirstatus) {
		std::cerr << "Unable to create temporary working directory" << std::endl;
		return 1;
	}
	std::cout << "Made temporary working directory" << std::endl;

	leveldb::Options options;
	options.create_if_missing = true;

	leveldb::DB* locationDB;
	leveldb::Status locdbstatus = leveldb::DB::Open(options, "./ChunkerData/location", &locationDB);
	if (!locdbstatus.ok()) { std::cerr << locdbstatus.ToString() << std::endl; return 1; }

	leveldb::DB* sizeDB;
	leveldb::Status sizedbstatus = leveldb::DB::Open(options, "./ChunkerData/size", &sizeDB);
	if (!sizedbstatus.ok()) { std::cerr << sizedbstatus.ToString() << std::endl; return 1; }

	std::cout << "Made databases" << std::endl;

	std::ofstream outfile("outputchunk", std::ios::binary);

	// Write format header
	const char* header = "SHADOW";
	// We don't want the nullchar at the end of the header
	outfile.write(header, strlen(header));

	uint32_t writeCursor = 0;

	unsigned char nullchar = 0x00;

	// Blank line for readability in the terminal
	std::cout << std::endl;

	// Loop through every file in given folder
	for (const auto& file : std::filesystem::recursive_directory_iterator(folderpath)) {
		std::cout << "Found file " << file.path().string() << std::endl;
		std::string fileNameStr = file.path().string();

		// Pour file contents into a stringstream
		// and turn it into a std::string
		std::ifstream iteratedFile(file.path().string());
		std::stringstream ss;
		ss << iteratedFile.rdbuf();
		std::string fileData = ss.str();

		// File contents should be in memory now, we'll use this to get
		// the size of the file and set an offset for our data section
		//
		// The write cursor is equal to 0 where the data section starts

		std::cout << "Writing now..." << std::endl;
		// Store the offset location
		leveldb::Slice dbCursor((char*)&writeCursor, sizeof(writeCursor));
		locationDB->Put(leveldb::WriteOptions(), fileNameStr, dbCursor);

		std::cout << "Reading as a test..." << std::endl;
		std::string readfromdb;
		leveldb::Status readstatus = locationDB->Get(leveldb::ReadOptions(), fileNameStr, &readfromdb);
		std::cout << (int)readfromdb << std::endl;

		// Store the file size
		//leveldb::Slice dbSize((char*)&fileData.size(), sizeof(fileData.size()));
		//sizeDB->Put(leveldb::WriteOptions(), fileNameStr, dbSize);

		iteratedFile.close();

		//std::cout << "Dumping file contents into chunk" << std::endl;

		//outfile << fileData;
		//writeCursor = writeCursor + (uint32_t) fileData.size();
		//std::cout << "Cursor at postion: " << writeCursor << std::endl;

/*
		// Write filename to block
		// Terminates at \0
		const char* filename = fileNameStr.c_str();
		outfile.write(filename, strlen(filename));
		outfile.write((char*)&nullchar, sizeof(nullchar));

		// Write Location of file in chunk, and filesize.
		// Two unsigned 32-bit ints
		// 4 bytes each
		uint32_t filelocation = 11532;
		outfile.write((char*)&filelocation, sizeof(filelocation));

		uint32_t encodedFilesize = (uint32_t) fileData.size();
		outfile.write((char*)&encodedFilesize, sizeof(encodedFilesize));
		*/

		// Blank line for readability in the terminal
		std::cout << std::endl;
	}

	delete locationDB;
	delete sizeDB;
	std::cout << "Closed databases" << std::endl;

	//std::filesystem::remove_all("./ChunkerData");
	//std::cout << "Deleted working directory" << std::endl;

	outfile.close();

	return 0;
}

/*int Chunker::chunkFolder(std::string folderpath, Chunker::CompressionType compression) {
	std::ifstream folderToChunk(folderpath);
	if (!folderToChunk) {
		std::cerr << "Unable to open given folder" << std::endl;
		return 1;
	}

	std::ofstream outfile("outputchunk", std::ios::binary);

	// Write format header
	const char* header = "SHADOW";
	// We don't want the nullchar at the end of the header
	outfile.write(header, strlen(header));

	// Loop through every file in given folder
	for (const auto& file : std::filesystem::recursive_directory_iterator(folderpath)) {
		std::cout << "Found file " << file.path().string() << std::endl;

		// Block Creation

		std::string fileNameStr = file.path().string();

		unsigned char nullchar = 0x00;

		// Pour file contents into a stringstream
		std::ifstream iteratedFile(file.path().string());
		std::stringstream ss;
		ss << iteratedFile.rdbuf();
		std::string fileData = ss.str();

		// Write filename to block
		// Terminates at \0
		const char* filename = fileNameStr.c_str();
		outfile.write(filename, strlen(filename));
		outfile.write((char*)&nullchar, sizeof(nullchar));


		// Encode and write filesize as unsigned 32-bit int
		// Takes up 4 bytes

		uint32_t encodedFilesize = (uint32_t) fileData.size();
		outfile.write((char*)&encodedFilesize, sizeof(encodedFilesize));

		// Write file content to chunk
		// use << because data can contain nullchars

		outfile << fileData;
	}

	outfile.close();

	switch (compression) {
		case None:
		case LZ4:
		break;
	}

	return 0;
}
*/
